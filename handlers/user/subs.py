from datetime import datetime
from typing import Any

from aiogram import Router, F
from aiogram.filters import Command
from aiogram.types import Message, CallbackQuery, LabeledPrice, PreCheckoutQuery

from database.context_manager import DatabaseContextManager
from keyboards.kb_inline import InlineKeyboards, SubscriptionCallbackFactory
from lexicon.lexicon_ru import LEXICON_RU
from logger.logging_config import logger

router = Router()


@router.message(Command(commands='subs'))
async def get_user_subs(message: Message):
    user_id = message.from_user.id
    async with DatabaseContextManager() as session:
        subscription_data = await session.subscription.get_subscription(user_id)
        if subscription_data is None:
            await message.answer(text=LEXICON_RU['not_exists'])
            return
        for data in subscription_data:
            start_date = data.start_date
            end_date = data.end_date
            vpn_key = data.key
            server_name = data.server_name
            service_name = data.name
            status = data.status

            parseSubs = (
                f"üì∂ –°—Ç–∞—Ç—É—Å: {'üü¢ –ê–∫—Ç–∏–≤–Ω–∞' if status == '–∞–∫—Ç–∏–≤–Ω–∞—è' else 'üî¥ –ò—Å—Ç–µ–∫–ª–∞'}\n"
                f"üíº –£—Å–ª—É–≥–∞: {service_name}\n\n"
                f"üìÜ –î–∞—Ç–∞ –Ω–∞—á–∞–ª–∞: {start_date.strftime('%Y-%m-%d')}\n"
                f"üìÜ –î–∞—Ç–∞ –æ–∫–æ–Ω—á–∞–Ω–∏—è: {end_date.strftime('%Y-%m-%d')}\n\n"
                f"–°—Ç—Ä–∞–Ω–∞: {server_name}\n"
                f"üîë –ö–ª—é—á: {vpn_key}"
            )

            if status == '–∏—Å—Ç–µ–∫–ª–∞':
                keyboard = await InlineKeyboards.extend_subscription(data.subscription_id)
                await message.answer(
                    text=parseSubs + "\n\nüîÑ –í–∞—à–∞ –ø–æ–¥–ø–∏—Å–∫–∞ –∏—Å—Ç–µ–∫–ª–∞. –•–æ—Ç–∏—Ç–µ –ø—Ä–æ–¥–ª–∏—Ç—å?",
                    reply_markup=keyboard
                )
            else:
                await message.answer(text=parseSubs)


@router.callback_query(SubscriptionCallbackFactory.filter(F.action == 'extend_subscription'))
async def extend_subscription(callback: CallbackQuery, callback_data: SubscriptionCallbackFactory):
    subscription_id = callback_data.subscription_id

    keyboard = await InlineKeyboards.extend_subscription_options(subscription_id)
    await callback.message.answer(
        text=LEXICON_RU['extend_sub'],
        reply_markup=keyboard,
    )
    await callback.answer()


@router.callback_query(SubscriptionCallbackFactory.filter(F.action == 'extend_with_key'))
async def extend_with_key(callback: CallbackQuery, callback_data: SubscriptionCallbackFactory):
    subscription_id = callback_data.subscription_id
    async with DatabaseContextManager() as session_methods:
        try:
            subs = await session_methods.subscription.get_subscription(callback.from_user.id)
            if subs:
                for sub in subs:
                    if sub.subscription_id == subscription_id:
                        await send_invoice_handler(message=callback.message, sub=sub)
                        break
            else:
                raise

        except Exception as e:
            logger.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–¥–ª–µ–Ω–∏–∏ –ø–æ–¥–ø–∏—Å–∫–∏', e)
            await callback.message.answer(text="–ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫, –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ —Ç–µ—Ö–ø–æ–¥–¥–µ—Ä–∂–∫—É")




@router.callback_query(SubscriptionCallbackFactory.filter(F.action == 'new_order'))
async def new_order(callback: CallbackQuery, callback_data: SubscriptionCallbackFactory):
    subscription_id = callback_data.subscription_id
    await callback.message.answer("–û—Ñ–æ—Ä–º–ª–µ–Ω –Ω–æ–≤—ã–π –∑–∞–∫–∞–∑.")
    await callback.answer()


async def send_invoice_handler(message: Message, sub: Any):
    try:

        prices = [LabeledPrice(label="XTR", amount=1)]
        await message.answer_invoice(
            title=f"VPN –Ω–∞ {sub.name}",
            description=f"–î–ª—è –ø—Ä–æ–¥–ª–µ–Ω–∏—è –ø–æ–¥–ø–∏—Å–∫–∏, –æ–ø–ª–∞—Ç–∏ {sub.price} –∑–≤–µ–∑–¥ –ø–æ —Å—Å—ã–ª–∫–µ –Ω–∏–∂–µ.\n",
            prices=prices,
            provider_token="",
            payload=f"{sub.service_id}:{sub.duration_days}:{sub.server_id}",
            currency="XTR",
            reply_markup=await InlineKeyboards.create_pay(1),
        )
    except Exception as e:
        logger.error(f"–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: {e}")
        await message.answer(text="–ß—Ç–æ-—Ç–æ –ø–æ—à–ª–æ –Ω–µ —Ç–∞–∫, –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ —Ç–µ—Ö–ø–æ–¥–¥–µ—Ä–∂–∫—É")


# @router.pre_checkout_query()
# async def pre_checkout_query(query: PreCheckoutQuery):
#     await query.answer(ok=True)
#
#
# @router.message(F.successful_payment)
# async def successful_payment(message: Message):
#     await extend_sub_successful_payment(message)